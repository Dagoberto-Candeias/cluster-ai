apiVersion: apps/v1
kind: Deployment
metadata:
  name: cluster-ai-model-registry
  namespace: cluster-ai
  labels:
    app.kubernetes.io/name: model-registry
    app.kubernetes.io/component: ml-serving
    app.kubernetes.io/part-of: cluster-ai
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: model-registry
  template:
    metadata:
      labels:
        app.kubernetes.io/name: model-registry
        app.kubernetes.io/component: ml-serving
    spec:
      containers:
      - name: model-registry
        image: python:3.11-slim
        ports:
        - containerPort: 8000
          name: http
        command:
        - python
        - /app/model_registry.py
        env:
        - name: REDIS_HOST
          value: "cluster-ai-model-cache"
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cluster-ai-model-cache-secret
              key: password
        volumeMounts:
        - name: registry-script
          mountPath: /app
        - name: model-storage
          mountPath: /models
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: "/health"
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: "/health"
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: registry-script
        configMap:
          name: cluster-ai-model-registry-config
      - name: model-storage
        persistentVolumeClaim:
          claimName: cluster-ai-models-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: cluster-ai-model-registry
  namespace: cluster-ai
  labels:
    app.kubernetes.io/name: model-registry
    app.kubernetes.io/component: ml-serving
    app.kubernetes.io/part-of: cluster-ai
spec:
  ports:
  - name: http
    port: 8000
    targetPort: 8000
  selector:
    app.kubernetes.io/name: model-registry
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-ai-model-registry-config
  namespace: cluster-ai
  labels:
    app.kubernetes.io/name: model-registry
    app.kubernetes.io/component: ml-serving
    app.kubernetes.io/part-of: cluster-ai
data:
  model_registry.py: |
    #!/usr/bin/env python3
    from flask import Flask, request, jsonify
    import redis
    import json
    import os
    import hashlib
    from datetime import datetime
    import logging

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    app = Flask(__name__)

    class ModelRegistry:
        def __init__(self):
            self.redis_host = os.getenv('REDIS_HOST', 'localhost')
            self.redis_password = os.getenv('REDIS_PASSWORD', '')
            self.redis = redis.Redis(
                host=self.redis_host,
                password=self.redis_password,
                decode_responses=True
            )

        def register_model(self, model_name, version, model_path, metadata=None):
            """Register a new model version"""
            try:
                # Calculate model hash for integrity check
                if os.path.exists(model_path):
                    with open(model_path, 'rb') as f:
                        model_hash = hashlib.sha256(f.read()).hexdigest()
                else:
                    model_hash = "unknown"

                model_info = {
                    'name': model_name,
                    'version': version,
                    'path': model_path,
                    'hash': model_hash,
                    'registered_at': datetime.now().isoformat(),
                    'status': 'registered',
                    'metadata': metadata or {}
                }

                # Store in Redis
                key = f'model_registry:{model_name}:{version}'
                self.redis.set(key, json.dumps(model_info))

                # Update latest version
                self.redis.set(f'model_registry:{model_name}:latest', version)

                logger.info(f"Registered model {model_name} version {version}")
                return True

            except Exception as e:
                logger.error(f"Error registering model: {e}")
                return False

        def get_model_info(self, model_name, version=None):
            """Get model information"""
            try:
                if version is None:
                    version = self.redis.get(f'model_registry:{model_name}:latest')

                if version:
                    key = f'model_registry:{model_name}:{version}'
                    data = self.redis.get(key)
                    if data:
                        return json.loads(data)

                return None

            except Exception as e:
                logger.error(f"Error getting model info: {e}")
                return None

        def list_model_versions(self, model_name):
            """List all versions of a model"""
            try:
                keys = self.redis.keys(f'model_registry:{model_name}:*')
                versions = []

                for key in keys:
                    if not key.endswith(':latest'):
                        version = key.split(':')[-1]
                        versions.append(version)

                return sorted(versions, reverse=True)

            except Exception as e:
                logger.error(f"Error listing model versions: {e}")
                return []

        def promote_model(self, model_name, version, environment):
            """Promote model to different environment"""
            try:
                model_info = self.get_model_info(model_name, version)
                if model_info:
                    model_info['environment'] = environment
                    model_info['promoted_at'] = datetime.now().isoformat()

                    key = f'model_registry:{model_name}:{version}'
                    self.redis.set(key, json.dumps(model_info))

                    # Set as latest for environment
                    self.redis.set(f'model_registry:{model_name}:{environment}', version)

                    logger.info(f"Promoted model {model_name}:{version} to {environment}")
                    return True

                return False

            except Exception as e:
                logger.error(f"Error promoting model: {e}")
                return False

    registry = ModelRegistry()

    @app.route('/health')
    def health():
        return {'status': 'healthy'}

    @app.route('/models', methods=['GET'])
    def list_models():
        try:
            keys = registry.redis.keys('model_registry:*:latest')
            models = []

            for key in keys:
                model_name = key.split(':')[1]
                latest_version = registry.redis.get(key)
                model_info = registry.get_model_info(model_name, latest_version)

                if model_info:
                    models.append({
                        'name': model_name,
                        'latest_version': latest_version,
                        'status': model_info.get('status'),
                        'registered_at': model_info.get('registered_at')
                    })

            return jsonify({'models': models})

        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/models/<model_name>', methods=['GET'])
    def get_model(model_name):
        version = request.args.get('version')
        model_info = registry.get_model_info(model_name, version)

        if model_info:
            return jsonify(model_info)
        else:
            return jsonify({'error': 'Model not found'}), 404

    @app.route('/models/<model_name>/versions', methods=['GET'])
    def list_versions(model_name):
        versions = registry.list_model_versions(model_name)
        return jsonify({'versions': versions})

    @app.route('/models', methods=['POST'])
    def register_model():
        data = request.json

        if not data or 'name' not in data or 'version' not in data:
            return jsonify({'error': 'Missing required fields: name, version'}), 400

        success = registry.register_model(
            data['name'],
            data['version'],
            data.get('path', f"/models/{data['name']}_{data['version']}.pt"),
            data.get('metadata')
        )

        if success:
            return jsonify({'message': 'Model registered successfully'})
        else:
            return jsonify({'error': 'Failed to register model'}), 500

    @app.route('/models/<model_name>/promote', methods=['POST'])
    def promote_model(model_name):
        data = request.json

        if not data or 'version' not in data or 'environment' not in data:
            return jsonify({'error': 'Missing required fields: version, environment'}), 400

        success = registry.promote_model(model_name, data['version'], data['environment'])

        if success:
            return jsonify({'message': f'Model promoted to {data["environment"]}'})
        else:
            return jsonify({'error': 'Failed to promote model'}), 500

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8000)
